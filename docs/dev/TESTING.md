# Testing

This document describe how to add new unit tests for different
components, and how to use the mockery tool.

Actually this repository is using `testify` library for unit testing,
so you will find in the majority of the `_test.go` files the imports
below:

```golang
import (
  "testing"
  "github.com/stretchr/testify/assert"
  "github.com/stretchr/testify/require"
  "github.com/stretchr/testify/mock"
)
```

More information about [testify here](https://pkg.go.dev/github.com/stretchr/testify).

Additional libraries and tools used are:

- [mockery](https://github.com/vektra/mockery) to generate the mocks
  for the defined interfaces.
- [sqlmock](https://github.com/DATA-DOG/go-sqlmock) to test the gorm
  components without a database running.

## Generating mocks

If you have added code which add a new interface, you will want
to generate mocks for your interface:

- If you added a new directory, check that `MOCK_DIRS` at `mk/go-rules.mk` file
  contain your new directory.
- Generate the mocks by: `make generate-mock`.
- Now you can find the mocks at the base directory `internal/test/mock`.

## General tips

- Use vscode coverage tools to see the paths that are not covered, and take
  advantage of it by:
  - Testing from inner dependencies to outer.
    - interactor, presenter, and repository packages use to be into the leaves
      of the dependencies.
    - handlers (http and event), middleware.
    - routers, services.
    - commands
  - Testing from earlier paths in a method to the deeper paths, so the coverage
    tool in vscode can drive pending flows to cover.
- Use mock objects generated by `make generate-mock`. This will save a lot of
  time avoiding to code the mock boilerplate.
- Refactor if necessary to make the unit test simpler.

## Running container with iqe shell

```sh
podman run -ti \
  -e ENV_FOR_DYNACONF=ephemeral \
  -e NAMESPACE="$( oc project -q )" \
  --entrypoint=/bin/bash \
  quay.io/cloudservices/iqe-core:latest
```

## Launching integration tests on ephemeral

```sh
# IQE plugins are comma separated
IQE_PLUGINS="idmsvc"
ENV_FOR_DYNACONF=clowder_smoke
bonfire deploy-iqe-cji \
  --plugins "${IQE_PLUGINS}" \
  --env "${ENV_FOR_DYNACONF}" \
  --cji-name idmsvc-backend \
  --namespace "$( oc project -q )" \
  idmsvc-backend
# see: bonfire deploy-iqe-cji --help
```

or using the rule: `make ephemeral-test-backend`

## Unit test for interactor

For each method to test, define a unit test with a table
so that we consider for the different inputs, the
expected outputs and errors; the table will allow to
gather several situations to be validated.

The unit tests on those components are about validate
the data transformation.

Example:

```golang
type TestCaseGiven struct {
  Params *api_public.CreateTodoParams
  In     *api_public.Todo
  Out    *model.Todo
}
type TestCaseExpected struct {
  Err error
  Out *model.Todo
}
type TestCase struct {
  Name     string
  Given    TestCaseGiven
  Expected TestCaseExpected
}
testCases := []TestCase{...}
// Eventually interact the test cases and check the output
for _, testCase := range testCases {
  t.Log(testCase.Name)
  component := NewTodoInteractor()
  err := component.Create(testCase.Given.Params, testCase.Given.In, out)
  // Add assertions for the expected result
  // ...
}
```

## Unit test for repository

For those components, we check that the database operations to
launch are the expected ones, given the input data.

To check that, `sqlmock` is used. This allow to launch unit
tests without a database up and running.

Below an example preparing a mock which envolve a dynamic time.Time field (at: `internal/usecase/repository/domain_repository.go`)

```golang
s.mock.ExpectQuery(regexp.QuoteMeta(`INSERT INTO "ipas" ("created_at","updated_at","deleted_at","realm_name","realm_domains","id") VALUES ($1,$2,$3,$4,$5,$6) RETURNING "id"`)).
		WithArgs(
			data.IpaDomain.Model.CreatedAt,
			data.IpaDomain.Model.UpdatedAt,
			nil,

			data.IpaDomain.RealmName,
			data.IpaDomain.RealmDomains,
			data.IpaDomain.ID).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).
			AddRow(data.IpaDomain.ID))
```

---

Sometimes we could need more tracing; the below it was used to troubleshoot
some unit tests providing more traces without change the code.

```golang
func (s *Suite) SetupTest() {
	var err error

    logger.InitLogger(&config.Config{
		Logging: config.Logging{
			Console: true,
			Level:   "trace",
		},
	})

	s.mock, s.DB, err = test.NewSqlMock(&gorm.Session{
		SkipHooks: true,
		Logger: logger.NewGormLog(false),
	})
	if err != nil {
		s.Suite.FailNow("Error calling gorm.Open: %s", err.Error())
		return
	}
	s.repository = &domainRepository{}
}
```

---

One last tip when creating unit tests for the repository layer, we
could duplicate code very quickly trying to cover all the different
paths for the repository layer. One thing that have been used is
a helper function that prepare the database mock in several stages
in an incremental way; for hms-1937 it was used to reduce code
duplication.

```golang
func (s *Suite) helperTestFindByID(stage int, data *model.Domain, mock sqlmock.Sqlmock, expectedErr error) {
	for i := 1; i <= stage; i++ {
		switch i {
		case 1:
			expectQuery := s.mock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "domains" WHERE (org_id = $1 AND domain_uuid = $2) AND "domains"."deleted_at" IS NULL ORDER BY "domains"."id" LIMIT 1`)).
				WithArgs(
					data.OrgId,
					data.DomainUuid,
				)
			if i == stage && expectedErr != nil {
				expectQuery.WillReturnError(expectedErr)
			} else {
				autoenrollment := false
				if data.AutoEnrollmentEnabled != nil {
					autoenrollment = *data.AutoEnrollmentEnabled
				}
				expectQuery.WillReturnRows(sqlmock.NewRows([]string{
					"id", "created_at", "updated_at", "deletet_at",

					"org_id", "domain_uuid", "domain_name",
					"title", "description", "type",
					"auto_enrollment_enabled",
				}).
					AddRow(
						data.ID,
						data.CreatedAt,
						data.UpdatedAt,
						nil,

						data.OrgId,
						data.DomainUuid,
						data.DomainName,
						data.Title,
						data.Description,
						data.Type,
						autoenrollment,
					))
			}
    // ... Additional stages here
		case 5:
			expectedQuery := s.mock.ExpectQuery(regexp.QuoteMeta(`SELECT * FROM "ipa_servers" WHERE "ipa_servers"."ipa_id" = $1 AND "ipa_servers"."deleted_at" IS NULL`)).
				WithArgs(1)
			if i == stage && expectedErr != nil {
				expectedQuery.WillReturnError(expectedErr)
			} else {
				expectedQuery.WillReturnRows(sqlmock.NewRows([]string{
					"id", "created_at", "updated_at", "deletet_at",

					"ipa_id", "fqdn", "rhsm_id", "location",
					"ca_server", "hcc_enrollment_server", "hcc_update_server",
					"pk_init_server",
				}).
					AddRow(
						data.IpaDomain.Servers[0].Model.ID,
						data.IpaDomain.Servers[0].Model.CreatedAt,
						data.IpaDomain.Servers[0].Model.UpdatedAt,
						data.IpaDomain.Servers[0].Model.DeletedAt,

						data.IpaDomain.Servers[0].IpaID,
						data.IpaDomain.Servers[0].FQDN,
						data.IpaDomain.Servers[0].RHSMId,
						data.IpaDomain.Servers[0].Location,
						data.IpaDomain.Servers[0].CaServer,
						data.IpaDomain.Servers[0].HCCEnrollmentServer,
						data.IpaDomain.Servers[0].HCCUpdateServer,
						data.IpaDomain.Servers[0].PKInitServer,
					))
			}
		default:
			panic(fmt.Sprintf("scenario %d/%d is not supported", i, stage))
		}
	}
}
```

Later in the unit test we just do:

```golang
// Check for 'ipas' record not found
expectedErr = gorm.ErrRecordNotFound
s.helperTestFindByID(2, data, s.mock, expectedErr)
domain, err = r.FindByID(s.DB, data.OrgId, data.DomainUuid.String())
require.NoError(t, s.mock.ExpectationsWereMet())
assert.EqualError(t, err, expectedErr.Error())
assert.Nil(t, domain)
```

The above could not be valid for all our scenarios, but is an
option to keep in mind when we are implementing the unit tests
for the repository layer.

---

References:

- https://medium.com/@rosaniline/unit-testing-gorm-with-go-sqlmock-in-go-93cbce1f6b5b
  - https://github.com/Rosaniline/gorm-ut
- https://pkg.go.dev/github.com/stretchr/testify/suite

## Unit test for presenters

Presenters are the opposite to interactors, and they
translate the resulting business model into the API
output. They are tested in a similar way to the
interactors. They don't store any state, and gather
a set of methods for the transformations.

We validate the transformation and errors returned
are the expected in a similar way as the interactor.

## Unit test for a middleware

Isolate tests for the middlewares require to set
up a basic `echo` instance with the state of
the middleware we want to test. To make things
easier we will define a helper function that
allow that by injecting the specified middleware.
Such as the below code:

```golang
func helperNewEcho(middleware echo_middleware.MiddlewareFunc) error {
  // This will return an echo instance ready with the configuration we need
  e := echo.New()
	h := func(c echo.Context) error {
		return c.String(http.StatusOK, "Ok")
	}
	e.Use(middleware)
	e.Add("GET", testPath, h)

	return e
}
```

Now use that to help you to create the use cases,
the below is something general.

```golang
type TestCaseGiven struct {
  Method string
  Path string
  Body string
  Headers map[string]string
}
type TestCaseExpected struct {
  Code int
  Body string
}
type TestCase struct {
  Name     string
  Given    TestCaseGiven
  Expected TestCaseExpected
}

testCases := []TestCase{}
```

Now loop your use cases and check that everything behave
as expected:

```golang
	for _, testCase := range testCases {
		res := httptest.NewRecorder()
		req := httptest.NewRequest(testCase.Given.Method, testCase.Given.Path, testCase.Given.Body)
    if testCase.Given.Headers != nil {
      for key, value := range testCase.Given.Headers {
        req.Header.Add(key, value)
      }
    }
		e.ServeHTTP(res, req)

		// Check expectations
		data, err := ioutil.ReadAll(res.Body)
		require.NoError(t, err)
		assert.Equal(t, testCase.Expected.Code, res.Code)
		assert.Equal(t, testCase.Expected.Body, string(data))
	}
```

## Testing client components

Client components represent the integration with third party
services that we use by http requests. The intention to
create a specific package for them (and interface) is to
provide a way to mock them into the handler (see next
section).

How work the internals for this? The basic is by starting
a service for the test which will return an expected
status code and body response to some request, so when
our client component that we are developing will get
that response, and we can check if for that given
pre-defined response it behaves as expected.

To make life easier, some code has been created
at: `./internal/test/client/server.go` which prepare
an echo instance for it.

For the inventory host client component has been
created some helper which wrap the above to use
only the arguments we need. See the tests for
inventory client component at:
`./internal/usecase/client/host_inventory_test.go`.

## TODO Unit test for a handler

FIXME It was seen that could be complicated to
      define a helper function to check specific
      handlers without start the whole service,
      so this part would need some refactor.

See: `internal/test/client/server.go`

## References

- https://pkg.go.dev/github.com/stretchr/testify
- https://pkg.go.dev/net/http/httptest
- https://github.com/vektra/mockery
- https://github.com/avisiedo/go-test-demo
